// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides

part of 'value_failure.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$ValueFailureTearOff {
  const _$ValueFailureTearOff();

  ExceedingLength<T> exceedingLength<T>(
      {required T failedMessage, required int lenght}) {
    return ExceedingLength<T>(
      failedMessage: failedMessage,
      lenght: lenght,
    );
  }

  InsufficientLength<T> insufficientLength<T>(
      {required T failedMessage, required int lenght}) {
    return InsufficientLength<T>(
      failedMessage: failedMessage,
      lenght: lenght,
    );
  }

  Empty<T> empty<T>({required T failedMessage}) {
    return Empty<T>(
      failedMessage: failedMessage,
    );
  }

  DifferentInput<T> differentInput<T>({required T failedMessage}) {
    return DifferentInput<T>(
      failedMessage: failedMessage,
    );
  }

  FailedInput<T> failedInput<T>({required T failedMessage}) {
    return FailedInput<T>(
      failedMessage: failedMessage,
    );
  }

  Multiline<T> multiline<T>({required T failedMessage}) {
    return Multiline<T>(
      failedMessage: failedMessage,
    );
  }

  NumberTooLarge<T> numberTooLarge<T>(
      {required T failedMessage, required num lenght}) {
    return NumberTooLarge<T>(
      failedMessage: failedMessage,
      lenght: lenght,
    );
  }

  ListTooLong<T> listTooLong<T>(
      {required T failedMessage, required int lenght}) {
    return ListTooLong<T>(
      failedMessage: failedMessage,
      lenght: lenght,
    );
  }

  InvalidEmail<T> invalidEmail<T>({required T failedMessage}) {
    return InvalidEmail<T>(
      failedMessage: failedMessage,
    );
  }

  ShortString<T> shortString<T>({required T failedMessage}) {
    return ShortString<T>(
      failedMessage: failedMessage,
    );
  }

  InvalidPhotoUrl<T> invalidPhotoUrl<T>({required T failedMessage}) {
    return InvalidPhotoUrl<T>(
      failedMessage: failedMessage,
    );
  }

  ValidateMinStringLength<T> validateMinStringLength<T>(
      {required T failedMessage}) {
    return ValidateMinStringLength<T>(
      failedMessage: failedMessage,
    );
  }

  MissingUpperCase<T> missingUpperCase<T>({required T failedMessage}) {
    return MissingUpperCase<T>(
      failedMessage: failedMessage,
    );
  }

  MissingLowerCase<T> missingLowerCase<T>({required T failedMessage}) {
    return MissingLowerCase<T>(
      failedMessage: failedMessage,
    );
  }

  MissingNumber<T> missingNumber<T>({required T failedMessage}) {
    return MissingNumber<T>(
      failedMessage: failedMessage,
    );
  }

  IncludeNumber<T> includeNumber<T>({required T failedMessage}) {
    return IncludeNumber<T>(
      failedMessage: failedMessage,
    );
  }
}

/// @nodoc
const $ValueFailure = _$ValueFailureTearOff();

/// @nodoc
mixin _$ValueFailure<T> {
  T get failedMessage => throw _privateConstructorUsedError;

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedMessage, int lenght) exceedingLength,
    required TResult Function(T failedMessage, int lenght) insufficientLength,
    required TResult Function(T failedMessage) empty,
    required TResult Function(T failedMessage) differentInput,
    required TResult Function(T failedMessage) failedInput,
    required TResult Function(T failedMessage) multiline,
    required TResult Function(T failedMessage, num lenght) numberTooLarge,
    required TResult Function(T failedMessage, int lenght) listTooLong,
    required TResult Function(T failedMessage) invalidEmail,
    required TResult Function(T failedMessage) shortString,
    required TResult Function(T failedMessage) invalidPhotoUrl,
    required TResult Function(T failedMessage) validateMinStringLength,
    required TResult Function(T failedMessage) missingUpperCase,
    required TResult Function(T failedMessage) missingLowerCase,
    required TResult Function(T failedMessage) missingNumber,
    required TResult Function(T failedMessage) includeNumber,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedMessage, int lenght)? exceedingLength,
    TResult Function(T failedMessage, int lenght)? insufficientLength,
    TResult Function(T failedMessage)? empty,
    TResult Function(T failedMessage)? differentInput,
    TResult Function(T failedMessage)? failedInput,
    TResult Function(T failedMessage)? multiline,
    TResult Function(T failedMessage, num lenght)? numberTooLarge,
    TResult Function(T failedMessage, int lenght)? listTooLong,
    TResult Function(T failedMessage)? invalidEmail,
    TResult Function(T failedMessage)? shortString,
    TResult Function(T failedMessage)? invalidPhotoUrl,
    TResult Function(T failedMessage)? validateMinStringLength,
    TResult Function(T failedMessage)? missingUpperCase,
    TResult Function(T failedMessage)? missingLowerCase,
    TResult Function(T failedMessage)? missingNumber,
    TResult Function(T failedMessage)? includeNumber,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(InsufficientLength<T> value) insufficientLength,
    required TResult Function(Empty<T> value) empty,
    required TResult Function(DifferentInput<T> value) differentInput,
    required TResult Function(FailedInput<T> value) failedInput,
    required TResult Function(Multiline<T> value) multiline,
    required TResult Function(NumberTooLarge<T> value) numberTooLarge,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortString<T> value) shortString,
    required TResult Function(InvalidPhotoUrl<T> value) invalidPhotoUrl,
    required TResult Function(ValidateMinStringLength<T> value)
        validateMinStringLength,
    required TResult Function(MissingUpperCase<T> value) missingUpperCase,
    required TResult Function(MissingLowerCase<T> value) missingLowerCase,
    required TResult Function(MissingNumber<T> value) missingNumber,
    required TResult Function(IncludeNumber<T> value) includeNumber,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(InsufficientLength<T> value)? insufficientLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(DifferentInput<T> value)? differentInput,
    TResult Function(FailedInput<T> value)? failedInput,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(NumberTooLarge<T> value)? numberTooLarge,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortString<T> value)? shortString,
    TResult Function(InvalidPhotoUrl<T> value)? invalidPhotoUrl,
    TResult Function(ValidateMinStringLength<T> value)? validateMinStringLength,
    TResult Function(MissingUpperCase<T> value)? missingUpperCase,
    TResult Function(MissingLowerCase<T> value)? missingLowerCase,
    TResult Function(MissingNumber<T> value)? missingNumber,
    TResult Function(IncludeNumber<T> value)? includeNumber,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ValueFailureCopyWith<T, ValueFailure<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ValueFailureCopyWith<T, $Res> {
  factory $ValueFailureCopyWith(
          ValueFailure<T> value, $Res Function(ValueFailure<T>) then) =
      _$ValueFailureCopyWithImpl<T, $Res>;
  $Res call({T failedMessage});
}

/// @nodoc
class _$ValueFailureCopyWithImpl<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  _$ValueFailureCopyWithImpl(this._value, this._then);

  final ValueFailure<T> _value;
  // ignore: unused_field
  final $Res Function(ValueFailure<T>) _then;

  @override
  $Res call({
    Object? failedMessage = freezed,
  }) {
    return _then(_value.copyWith(
      failedMessage: failedMessage == freezed
          ? _value.failedMessage
          : failedMessage // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc
abstract class $ExceedingLengthCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $ExceedingLengthCopyWith(
          ExceedingLength<T> value, $Res Function(ExceedingLength<T>) then) =
      _$ExceedingLengthCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedMessage, int lenght});
}

/// @nodoc
class _$ExceedingLengthCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $ExceedingLengthCopyWith<T, $Res> {
  _$ExceedingLengthCopyWithImpl(
      ExceedingLength<T> _value, $Res Function(ExceedingLength<T>) _then)
      : super(_value, (v) => _then(v as ExceedingLength<T>));

  @override
  ExceedingLength<T> get _value => super._value as ExceedingLength<T>;

  @override
  $Res call({
    Object? failedMessage = freezed,
    Object? lenght = freezed,
  }) {
    return _then(ExceedingLength<T>(
      failedMessage: failedMessage == freezed
          ? _value.failedMessage
          : failedMessage // ignore: cast_nullable_to_non_nullable
              as T,
      lenght: lenght == freezed
          ? _value.lenght
          : lenght // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$ExceedingLength<T> implements ExceedingLength<T> {
  const _$ExceedingLength({required this.failedMessage, required this.lenght});

  @override
  final T failedMessage;
  @override
  final int lenght;

  @override
  String toString() {
    return 'ValueFailure<$T>.exceedingLength(failedMessage: $failedMessage, lenght: $lenght)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ExceedingLength<T> &&
            (identical(other.failedMessage, failedMessage) ||
                const DeepCollectionEquality()
                    .equals(other.failedMessage, failedMessage)) &&
            (identical(other.lenght, lenght) ||
                const DeepCollectionEquality().equals(other.lenght, lenght)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(failedMessage) ^
      const DeepCollectionEquality().hash(lenght);

  @JsonKey(ignore: true)
  @override
  $ExceedingLengthCopyWith<T, ExceedingLength<T>> get copyWith =>
      _$ExceedingLengthCopyWithImpl<T, ExceedingLength<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedMessage, int lenght) exceedingLength,
    required TResult Function(T failedMessage, int lenght) insufficientLength,
    required TResult Function(T failedMessage) empty,
    required TResult Function(T failedMessage) differentInput,
    required TResult Function(T failedMessage) failedInput,
    required TResult Function(T failedMessage) multiline,
    required TResult Function(T failedMessage, num lenght) numberTooLarge,
    required TResult Function(T failedMessage, int lenght) listTooLong,
    required TResult Function(T failedMessage) invalidEmail,
    required TResult Function(T failedMessage) shortString,
    required TResult Function(T failedMessage) invalidPhotoUrl,
    required TResult Function(T failedMessage) validateMinStringLength,
    required TResult Function(T failedMessage) missingUpperCase,
    required TResult Function(T failedMessage) missingLowerCase,
    required TResult Function(T failedMessage) missingNumber,
    required TResult Function(T failedMessage) includeNumber,
  }) {
    return exceedingLength(failedMessage, lenght);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedMessage, int lenght)? exceedingLength,
    TResult Function(T failedMessage, int lenght)? insufficientLength,
    TResult Function(T failedMessage)? empty,
    TResult Function(T failedMessage)? differentInput,
    TResult Function(T failedMessage)? failedInput,
    TResult Function(T failedMessage)? multiline,
    TResult Function(T failedMessage, num lenght)? numberTooLarge,
    TResult Function(T failedMessage, int lenght)? listTooLong,
    TResult Function(T failedMessage)? invalidEmail,
    TResult Function(T failedMessage)? shortString,
    TResult Function(T failedMessage)? invalidPhotoUrl,
    TResult Function(T failedMessage)? validateMinStringLength,
    TResult Function(T failedMessage)? missingUpperCase,
    TResult Function(T failedMessage)? missingLowerCase,
    TResult Function(T failedMessage)? missingNumber,
    TResult Function(T failedMessage)? includeNumber,
    required TResult orElse(),
  }) {
    if (exceedingLength != null) {
      return exceedingLength(failedMessage, lenght);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(InsufficientLength<T> value) insufficientLength,
    required TResult Function(Empty<T> value) empty,
    required TResult Function(DifferentInput<T> value) differentInput,
    required TResult Function(FailedInput<T> value) failedInput,
    required TResult Function(Multiline<T> value) multiline,
    required TResult Function(NumberTooLarge<T> value) numberTooLarge,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortString<T> value) shortString,
    required TResult Function(InvalidPhotoUrl<T> value) invalidPhotoUrl,
    required TResult Function(ValidateMinStringLength<T> value)
        validateMinStringLength,
    required TResult Function(MissingUpperCase<T> value) missingUpperCase,
    required TResult Function(MissingLowerCase<T> value) missingLowerCase,
    required TResult Function(MissingNumber<T> value) missingNumber,
    required TResult Function(IncludeNumber<T> value) includeNumber,
  }) {
    return exceedingLength(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(InsufficientLength<T> value)? insufficientLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(DifferentInput<T> value)? differentInput,
    TResult Function(FailedInput<T> value)? failedInput,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(NumberTooLarge<T> value)? numberTooLarge,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortString<T> value)? shortString,
    TResult Function(InvalidPhotoUrl<T> value)? invalidPhotoUrl,
    TResult Function(ValidateMinStringLength<T> value)? validateMinStringLength,
    TResult Function(MissingUpperCase<T> value)? missingUpperCase,
    TResult Function(MissingLowerCase<T> value)? missingLowerCase,
    TResult Function(MissingNumber<T> value)? missingNumber,
    TResult Function(IncludeNumber<T> value)? includeNumber,
    required TResult orElse(),
  }) {
    if (exceedingLength != null) {
      return exceedingLength(this);
    }
    return orElse();
  }
}

abstract class ExceedingLength<T> implements ValueFailure<T> {
  const factory ExceedingLength(
      {required T failedMessage, required int lenght}) = _$ExceedingLength<T>;

  @override
  T get failedMessage => throw _privateConstructorUsedError;
  int get lenght => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  $ExceedingLengthCopyWith<T, ExceedingLength<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InsufficientLengthCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $InsufficientLengthCopyWith(InsufficientLength<T> value,
          $Res Function(InsufficientLength<T>) then) =
      _$InsufficientLengthCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedMessage, int lenght});
}

/// @nodoc
class _$InsufficientLengthCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InsufficientLengthCopyWith<T, $Res> {
  _$InsufficientLengthCopyWithImpl(
      InsufficientLength<T> _value, $Res Function(InsufficientLength<T>) _then)
      : super(_value, (v) => _then(v as InsufficientLength<T>));

  @override
  InsufficientLength<T> get _value => super._value as InsufficientLength<T>;

  @override
  $Res call({
    Object? failedMessage = freezed,
    Object? lenght = freezed,
  }) {
    return _then(InsufficientLength<T>(
      failedMessage: failedMessage == freezed
          ? _value.failedMessage
          : failedMessage // ignore: cast_nullable_to_non_nullable
              as T,
      lenght: lenght == freezed
          ? _value.lenght
          : lenght // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$InsufficientLength<T> implements InsufficientLength<T> {
  const _$InsufficientLength(
      {required this.failedMessage, required this.lenght});

  @override
  final T failedMessage;
  @override
  final int lenght;

  @override
  String toString() {
    return 'ValueFailure<$T>.insufficientLength(failedMessage: $failedMessage, lenght: $lenght)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InsufficientLength<T> &&
            (identical(other.failedMessage, failedMessage) ||
                const DeepCollectionEquality()
                    .equals(other.failedMessage, failedMessage)) &&
            (identical(other.lenght, lenght) ||
                const DeepCollectionEquality().equals(other.lenght, lenght)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(failedMessage) ^
      const DeepCollectionEquality().hash(lenght);

  @JsonKey(ignore: true)
  @override
  $InsufficientLengthCopyWith<T, InsufficientLength<T>> get copyWith =>
      _$InsufficientLengthCopyWithImpl<T, InsufficientLength<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedMessage, int lenght) exceedingLength,
    required TResult Function(T failedMessage, int lenght) insufficientLength,
    required TResult Function(T failedMessage) empty,
    required TResult Function(T failedMessage) differentInput,
    required TResult Function(T failedMessage) failedInput,
    required TResult Function(T failedMessage) multiline,
    required TResult Function(T failedMessage, num lenght) numberTooLarge,
    required TResult Function(T failedMessage, int lenght) listTooLong,
    required TResult Function(T failedMessage) invalidEmail,
    required TResult Function(T failedMessage) shortString,
    required TResult Function(T failedMessage) invalidPhotoUrl,
    required TResult Function(T failedMessage) validateMinStringLength,
    required TResult Function(T failedMessage) missingUpperCase,
    required TResult Function(T failedMessage) missingLowerCase,
    required TResult Function(T failedMessage) missingNumber,
    required TResult Function(T failedMessage) includeNumber,
  }) {
    return insufficientLength(failedMessage, lenght);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedMessage, int lenght)? exceedingLength,
    TResult Function(T failedMessage, int lenght)? insufficientLength,
    TResult Function(T failedMessage)? empty,
    TResult Function(T failedMessage)? differentInput,
    TResult Function(T failedMessage)? failedInput,
    TResult Function(T failedMessage)? multiline,
    TResult Function(T failedMessage, num lenght)? numberTooLarge,
    TResult Function(T failedMessage, int lenght)? listTooLong,
    TResult Function(T failedMessage)? invalidEmail,
    TResult Function(T failedMessage)? shortString,
    TResult Function(T failedMessage)? invalidPhotoUrl,
    TResult Function(T failedMessage)? validateMinStringLength,
    TResult Function(T failedMessage)? missingUpperCase,
    TResult Function(T failedMessage)? missingLowerCase,
    TResult Function(T failedMessage)? missingNumber,
    TResult Function(T failedMessage)? includeNumber,
    required TResult orElse(),
  }) {
    if (insufficientLength != null) {
      return insufficientLength(failedMessage, lenght);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(InsufficientLength<T> value) insufficientLength,
    required TResult Function(Empty<T> value) empty,
    required TResult Function(DifferentInput<T> value) differentInput,
    required TResult Function(FailedInput<T> value) failedInput,
    required TResult Function(Multiline<T> value) multiline,
    required TResult Function(NumberTooLarge<T> value) numberTooLarge,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortString<T> value) shortString,
    required TResult Function(InvalidPhotoUrl<T> value) invalidPhotoUrl,
    required TResult Function(ValidateMinStringLength<T> value)
        validateMinStringLength,
    required TResult Function(MissingUpperCase<T> value) missingUpperCase,
    required TResult Function(MissingLowerCase<T> value) missingLowerCase,
    required TResult Function(MissingNumber<T> value) missingNumber,
    required TResult Function(IncludeNumber<T> value) includeNumber,
  }) {
    return insufficientLength(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(InsufficientLength<T> value)? insufficientLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(DifferentInput<T> value)? differentInput,
    TResult Function(FailedInput<T> value)? failedInput,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(NumberTooLarge<T> value)? numberTooLarge,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortString<T> value)? shortString,
    TResult Function(InvalidPhotoUrl<T> value)? invalidPhotoUrl,
    TResult Function(ValidateMinStringLength<T> value)? validateMinStringLength,
    TResult Function(MissingUpperCase<T> value)? missingUpperCase,
    TResult Function(MissingLowerCase<T> value)? missingLowerCase,
    TResult Function(MissingNumber<T> value)? missingNumber,
    TResult Function(IncludeNumber<T> value)? includeNumber,
    required TResult orElse(),
  }) {
    if (insufficientLength != null) {
      return insufficientLength(this);
    }
    return orElse();
  }
}

abstract class InsufficientLength<T> implements ValueFailure<T> {
  const factory InsufficientLength(
      {required T failedMessage,
      required int lenght}) = _$InsufficientLength<T>;

  @override
  T get failedMessage => throw _privateConstructorUsedError;
  int get lenght => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  $InsufficientLengthCopyWith<T, InsufficientLength<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EmptyCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $EmptyCopyWith(Empty<T> value, $Res Function(Empty<T>) then) =
      _$EmptyCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedMessage});
}

/// @nodoc
class _$EmptyCopyWithImpl<T, $Res> extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $EmptyCopyWith<T, $Res> {
  _$EmptyCopyWithImpl(Empty<T> _value, $Res Function(Empty<T>) _then)
      : super(_value, (v) => _then(v as Empty<T>));

  @override
  Empty<T> get _value => super._value as Empty<T>;

  @override
  $Res call({
    Object? failedMessage = freezed,
  }) {
    return _then(Empty<T>(
      failedMessage: failedMessage == freezed
          ? _value.failedMessage
          : failedMessage // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$Empty<T> implements Empty<T> {
  const _$Empty({required this.failedMessage});

  @override
  final T failedMessage;

  @override
  String toString() {
    return 'ValueFailure<$T>.empty(failedMessage: $failedMessage)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Empty<T> &&
            (identical(other.failedMessage, failedMessage) ||
                const DeepCollectionEquality()
                    .equals(other.failedMessage, failedMessage)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedMessage);

  @JsonKey(ignore: true)
  @override
  $EmptyCopyWith<T, Empty<T>> get copyWith =>
      _$EmptyCopyWithImpl<T, Empty<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedMessage, int lenght) exceedingLength,
    required TResult Function(T failedMessage, int lenght) insufficientLength,
    required TResult Function(T failedMessage) empty,
    required TResult Function(T failedMessage) differentInput,
    required TResult Function(T failedMessage) failedInput,
    required TResult Function(T failedMessage) multiline,
    required TResult Function(T failedMessage, num lenght) numberTooLarge,
    required TResult Function(T failedMessage, int lenght) listTooLong,
    required TResult Function(T failedMessage) invalidEmail,
    required TResult Function(T failedMessage) shortString,
    required TResult Function(T failedMessage) invalidPhotoUrl,
    required TResult Function(T failedMessage) validateMinStringLength,
    required TResult Function(T failedMessage) missingUpperCase,
    required TResult Function(T failedMessage) missingLowerCase,
    required TResult Function(T failedMessage) missingNumber,
    required TResult Function(T failedMessage) includeNumber,
  }) {
    return empty(failedMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedMessage, int lenght)? exceedingLength,
    TResult Function(T failedMessage, int lenght)? insufficientLength,
    TResult Function(T failedMessage)? empty,
    TResult Function(T failedMessage)? differentInput,
    TResult Function(T failedMessage)? failedInput,
    TResult Function(T failedMessage)? multiline,
    TResult Function(T failedMessage, num lenght)? numberTooLarge,
    TResult Function(T failedMessage, int lenght)? listTooLong,
    TResult Function(T failedMessage)? invalidEmail,
    TResult Function(T failedMessage)? shortString,
    TResult Function(T failedMessage)? invalidPhotoUrl,
    TResult Function(T failedMessage)? validateMinStringLength,
    TResult Function(T failedMessage)? missingUpperCase,
    TResult Function(T failedMessage)? missingLowerCase,
    TResult Function(T failedMessage)? missingNumber,
    TResult Function(T failedMessage)? includeNumber,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(failedMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(InsufficientLength<T> value) insufficientLength,
    required TResult Function(Empty<T> value) empty,
    required TResult Function(DifferentInput<T> value) differentInput,
    required TResult Function(FailedInput<T> value) failedInput,
    required TResult Function(Multiline<T> value) multiline,
    required TResult Function(NumberTooLarge<T> value) numberTooLarge,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortString<T> value) shortString,
    required TResult Function(InvalidPhotoUrl<T> value) invalidPhotoUrl,
    required TResult Function(ValidateMinStringLength<T> value)
        validateMinStringLength,
    required TResult Function(MissingUpperCase<T> value) missingUpperCase,
    required TResult Function(MissingLowerCase<T> value) missingLowerCase,
    required TResult Function(MissingNumber<T> value) missingNumber,
    required TResult Function(IncludeNumber<T> value) includeNumber,
  }) {
    return empty(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(InsufficientLength<T> value)? insufficientLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(DifferentInput<T> value)? differentInput,
    TResult Function(FailedInput<T> value)? failedInput,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(NumberTooLarge<T> value)? numberTooLarge,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortString<T> value)? shortString,
    TResult Function(InvalidPhotoUrl<T> value)? invalidPhotoUrl,
    TResult Function(ValidateMinStringLength<T> value)? validateMinStringLength,
    TResult Function(MissingUpperCase<T> value)? missingUpperCase,
    TResult Function(MissingLowerCase<T> value)? missingLowerCase,
    TResult Function(MissingNumber<T> value)? missingNumber,
    TResult Function(IncludeNumber<T> value)? includeNumber,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class Empty<T> implements ValueFailure<T> {
  const factory Empty({required T failedMessage}) = _$Empty<T>;

  @override
  T get failedMessage => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  $EmptyCopyWith<T, Empty<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DifferentInputCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $DifferentInputCopyWith(
          DifferentInput<T> value, $Res Function(DifferentInput<T>) then) =
      _$DifferentInputCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedMessage});
}

/// @nodoc
class _$DifferentInputCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $DifferentInputCopyWith<T, $Res> {
  _$DifferentInputCopyWithImpl(
      DifferentInput<T> _value, $Res Function(DifferentInput<T>) _then)
      : super(_value, (v) => _then(v as DifferentInput<T>));

  @override
  DifferentInput<T> get _value => super._value as DifferentInput<T>;

  @override
  $Res call({
    Object? failedMessage = freezed,
  }) {
    return _then(DifferentInput<T>(
      failedMessage: failedMessage == freezed
          ? _value.failedMessage
          : failedMessage // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$DifferentInput<T> implements DifferentInput<T> {
  const _$DifferentInput({required this.failedMessage});

  @override
  final T failedMessage;

  @override
  String toString() {
    return 'ValueFailure<$T>.differentInput(failedMessage: $failedMessage)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DifferentInput<T> &&
            (identical(other.failedMessage, failedMessage) ||
                const DeepCollectionEquality()
                    .equals(other.failedMessage, failedMessage)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedMessage);

  @JsonKey(ignore: true)
  @override
  $DifferentInputCopyWith<T, DifferentInput<T>> get copyWith =>
      _$DifferentInputCopyWithImpl<T, DifferentInput<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedMessage, int lenght) exceedingLength,
    required TResult Function(T failedMessage, int lenght) insufficientLength,
    required TResult Function(T failedMessage) empty,
    required TResult Function(T failedMessage) differentInput,
    required TResult Function(T failedMessage) failedInput,
    required TResult Function(T failedMessage) multiline,
    required TResult Function(T failedMessage, num lenght) numberTooLarge,
    required TResult Function(T failedMessage, int lenght) listTooLong,
    required TResult Function(T failedMessage) invalidEmail,
    required TResult Function(T failedMessage) shortString,
    required TResult Function(T failedMessage) invalidPhotoUrl,
    required TResult Function(T failedMessage) validateMinStringLength,
    required TResult Function(T failedMessage) missingUpperCase,
    required TResult Function(T failedMessage) missingLowerCase,
    required TResult Function(T failedMessage) missingNumber,
    required TResult Function(T failedMessage) includeNumber,
  }) {
    return differentInput(failedMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedMessage, int lenght)? exceedingLength,
    TResult Function(T failedMessage, int lenght)? insufficientLength,
    TResult Function(T failedMessage)? empty,
    TResult Function(T failedMessage)? differentInput,
    TResult Function(T failedMessage)? failedInput,
    TResult Function(T failedMessage)? multiline,
    TResult Function(T failedMessage, num lenght)? numberTooLarge,
    TResult Function(T failedMessage, int lenght)? listTooLong,
    TResult Function(T failedMessage)? invalidEmail,
    TResult Function(T failedMessage)? shortString,
    TResult Function(T failedMessage)? invalidPhotoUrl,
    TResult Function(T failedMessage)? validateMinStringLength,
    TResult Function(T failedMessage)? missingUpperCase,
    TResult Function(T failedMessage)? missingLowerCase,
    TResult Function(T failedMessage)? missingNumber,
    TResult Function(T failedMessage)? includeNumber,
    required TResult orElse(),
  }) {
    if (differentInput != null) {
      return differentInput(failedMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(InsufficientLength<T> value) insufficientLength,
    required TResult Function(Empty<T> value) empty,
    required TResult Function(DifferentInput<T> value) differentInput,
    required TResult Function(FailedInput<T> value) failedInput,
    required TResult Function(Multiline<T> value) multiline,
    required TResult Function(NumberTooLarge<T> value) numberTooLarge,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortString<T> value) shortString,
    required TResult Function(InvalidPhotoUrl<T> value) invalidPhotoUrl,
    required TResult Function(ValidateMinStringLength<T> value)
        validateMinStringLength,
    required TResult Function(MissingUpperCase<T> value) missingUpperCase,
    required TResult Function(MissingLowerCase<T> value) missingLowerCase,
    required TResult Function(MissingNumber<T> value) missingNumber,
    required TResult Function(IncludeNumber<T> value) includeNumber,
  }) {
    return differentInput(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(InsufficientLength<T> value)? insufficientLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(DifferentInput<T> value)? differentInput,
    TResult Function(FailedInput<T> value)? failedInput,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(NumberTooLarge<T> value)? numberTooLarge,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortString<T> value)? shortString,
    TResult Function(InvalidPhotoUrl<T> value)? invalidPhotoUrl,
    TResult Function(ValidateMinStringLength<T> value)? validateMinStringLength,
    TResult Function(MissingUpperCase<T> value)? missingUpperCase,
    TResult Function(MissingLowerCase<T> value)? missingLowerCase,
    TResult Function(MissingNumber<T> value)? missingNumber,
    TResult Function(IncludeNumber<T> value)? includeNumber,
    required TResult orElse(),
  }) {
    if (differentInput != null) {
      return differentInput(this);
    }
    return orElse();
  }
}

abstract class DifferentInput<T> implements ValueFailure<T> {
  const factory DifferentInput({required T failedMessage}) =
      _$DifferentInput<T>;

  @override
  T get failedMessage => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  $DifferentInputCopyWith<T, DifferentInput<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FailedInputCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $FailedInputCopyWith(
          FailedInput<T> value, $Res Function(FailedInput<T>) then) =
      _$FailedInputCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedMessage});
}

/// @nodoc
class _$FailedInputCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $FailedInputCopyWith<T, $Res> {
  _$FailedInputCopyWithImpl(
      FailedInput<T> _value, $Res Function(FailedInput<T>) _then)
      : super(_value, (v) => _then(v as FailedInput<T>));

  @override
  FailedInput<T> get _value => super._value as FailedInput<T>;

  @override
  $Res call({
    Object? failedMessage = freezed,
  }) {
    return _then(FailedInput<T>(
      failedMessage: failedMessage == freezed
          ? _value.failedMessage
          : failedMessage // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$FailedInput<T> implements FailedInput<T> {
  const _$FailedInput({required this.failedMessage});

  @override
  final T failedMessage;

  @override
  String toString() {
    return 'ValueFailure<$T>.failedInput(failedMessage: $failedMessage)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is FailedInput<T> &&
            (identical(other.failedMessage, failedMessage) ||
                const DeepCollectionEquality()
                    .equals(other.failedMessage, failedMessage)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedMessage);

  @JsonKey(ignore: true)
  @override
  $FailedInputCopyWith<T, FailedInput<T>> get copyWith =>
      _$FailedInputCopyWithImpl<T, FailedInput<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedMessage, int lenght) exceedingLength,
    required TResult Function(T failedMessage, int lenght) insufficientLength,
    required TResult Function(T failedMessage) empty,
    required TResult Function(T failedMessage) differentInput,
    required TResult Function(T failedMessage) failedInput,
    required TResult Function(T failedMessage) multiline,
    required TResult Function(T failedMessage, num lenght) numberTooLarge,
    required TResult Function(T failedMessage, int lenght) listTooLong,
    required TResult Function(T failedMessage) invalidEmail,
    required TResult Function(T failedMessage) shortString,
    required TResult Function(T failedMessage) invalidPhotoUrl,
    required TResult Function(T failedMessage) validateMinStringLength,
    required TResult Function(T failedMessage) missingUpperCase,
    required TResult Function(T failedMessage) missingLowerCase,
    required TResult Function(T failedMessage) missingNumber,
    required TResult Function(T failedMessage) includeNumber,
  }) {
    return failedInput(failedMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedMessage, int lenght)? exceedingLength,
    TResult Function(T failedMessage, int lenght)? insufficientLength,
    TResult Function(T failedMessage)? empty,
    TResult Function(T failedMessage)? differentInput,
    TResult Function(T failedMessage)? failedInput,
    TResult Function(T failedMessage)? multiline,
    TResult Function(T failedMessage, num lenght)? numberTooLarge,
    TResult Function(T failedMessage, int lenght)? listTooLong,
    TResult Function(T failedMessage)? invalidEmail,
    TResult Function(T failedMessage)? shortString,
    TResult Function(T failedMessage)? invalidPhotoUrl,
    TResult Function(T failedMessage)? validateMinStringLength,
    TResult Function(T failedMessage)? missingUpperCase,
    TResult Function(T failedMessage)? missingLowerCase,
    TResult Function(T failedMessage)? missingNumber,
    TResult Function(T failedMessage)? includeNumber,
    required TResult orElse(),
  }) {
    if (failedInput != null) {
      return failedInput(failedMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(InsufficientLength<T> value) insufficientLength,
    required TResult Function(Empty<T> value) empty,
    required TResult Function(DifferentInput<T> value) differentInput,
    required TResult Function(FailedInput<T> value) failedInput,
    required TResult Function(Multiline<T> value) multiline,
    required TResult Function(NumberTooLarge<T> value) numberTooLarge,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortString<T> value) shortString,
    required TResult Function(InvalidPhotoUrl<T> value) invalidPhotoUrl,
    required TResult Function(ValidateMinStringLength<T> value)
        validateMinStringLength,
    required TResult Function(MissingUpperCase<T> value) missingUpperCase,
    required TResult Function(MissingLowerCase<T> value) missingLowerCase,
    required TResult Function(MissingNumber<T> value) missingNumber,
    required TResult Function(IncludeNumber<T> value) includeNumber,
  }) {
    return failedInput(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(InsufficientLength<T> value)? insufficientLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(DifferentInput<T> value)? differentInput,
    TResult Function(FailedInput<T> value)? failedInput,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(NumberTooLarge<T> value)? numberTooLarge,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortString<T> value)? shortString,
    TResult Function(InvalidPhotoUrl<T> value)? invalidPhotoUrl,
    TResult Function(ValidateMinStringLength<T> value)? validateMinStringLength,
    TResult Function(MissingUpperCase<T> value)? missingUpperCase,
    TResult Function(MissingLowerCase<T> value)? missingLowerCase,
    TResult Function(MissingNumber<T> value)? missingNumber,
    TResult Function(IncludeNumber<T> value)? includeNumber,
    required TResult orElse(),
  }) {
    if (failedInput != null) {
      return failedInput(this);
    }
    return orElse();
  }
}

abstract class FailedInput<T> implements ValueFailure<T> {
  const factory FailedInput({required T failedMessage}) = _$FailedInput<T>;

  @override
  T get failedMessage => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  $FailedInputCopyWith<T, FailedInput<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MultilineCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $MultilineCopyWith(
          Multiline<T> value, $Res Function(Multiline<T>) then) =
      _$MultilineCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedMessage});
}

/// @nodoc
class _$MultilineCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $MultilineCopyWith<T, $Res> {
  _$MultilineCopyWithImpl(
      Multiline<T> _value, $Res Function(Multiline<T>) _then)
      : super(_value, (v) => _then(v as Multiline<T>));

  @override
  Multiline<T> get _value => super._value as Multiline<T>;

  @override
  $Res call({
    Object? failedMessage = freezed,
  }) {
    return _then(Multiline<T>(
      failedMessage: failedMessage == freezed
          ? _value.failedMessage
          : failedMessage // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$Multiline<T> implements Multiline<T> {
  const _$Multiline({required this.failedMessage});

  @override
  final T failedMessage;

  @override
  String toString() {
    return 'ValueFailure<$T>.multiline(failedMessage: $failedMessage)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Multiline<T> &&
            (identical(other.failedMessage, failedMessage) ||
                const DeepCollectionEquality()
                    .equals(other.failedMessage, failedMessage)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedMessage);

  @JsonKey(ignore: true)
  @override
  $MultilineCopyWith<T, Multiline<T>> get copyWith =>
      _$MultilineCopyWithImpl<T, Multiline<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedMessage, int lenght) exceedingLength,
    required TResult Function(T failedMessage, int lenght) insufficientLength,
    required TResult Function(T failedMessage) empty,
    required TResult Function(T failedMessage) differentInput,
    required TResult Function(T failedMessage) failedInput,
    required TResult Function(T failedMessage) multiline,
    required TResult Function(T failedMessage, num lenght) numberTooLarge,
    required TResult Function(T failedMessage, int lenght) listTooLong,
    required TResult Function(T failedMessage) invalidEmail,
    required TResult Function(T failedMessage) shortString,
    required TResult Function(T failedMessage) invalidPhotoUrl,
    required TResult Function(T failedMessage) validateMinStringLength,
    required TResult Function(T failedMessage) missingUpperCase,
    required TResult Function(T failedMessage) missingLowerCase,
    required TResult Function(T failedMessage) missingNumber,
    required TResult Function(T failedMessage) includeNumber,
  }) {
    return multiline(failedMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedMessage, int lenght)? exceedingLength,
    TResult Function(T failedMessage, int lenght)? insufficientLength,
    TResult Function(T failedMessage)? empty,
    TResult Function(T failedMessage)? differentInput,
    TResult Function(T failedMessage)? failedInput,
    TResult Function(T failedMessage)? multiline,
    TResult Function(T failedMessage, num lenght)? numberTooLarge,
    TResult Function(T failedMessage, int lenght)? listTooLong,
    TResult Function(T failedMessage)? invalidEmail,
    TResult Function(T failedMessage)? shortString,
    TResult Function(T failedMessage)? invalidPhotoUrl,
    TResult Function(T failedMessage)? validateMinStringLength,
    TResult Function(T failedMessage)? missingUpperCase,
    TResult Function(T failedMessage)? missingLowerCase,
    TResult Function(T failedMessage)? missingNumber,
    TResult Function(T failedMessage)? includeNumber,
    required TResult orElse(),
  }) {
    if (multiline != null) {
      return multiline(failedMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(InsufficientLength<T> value) insufficientLength,
    required TResult Function(Empty<T> value) empty,
    required TResult Function(DifferentInput<T> value) differentInput,
    required TResult Function(FailedInput<T> value) failedInput,
    required TResult Function(Multiline<T> value) multiline,
    required TResult Function(NumberTooLarge<T> value) numberTooLarge,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortString<T> value) shortString,
    required TResult Function(InvalidPhotoUrl<T> value) invalidPhotoUrl,
    required TResult Function(ValidateMinStringLength<T> value)
        validateMinStringLength,
    required TResult Function(MissingUpperCase<T> value) missingUpperCase,
    required TResult Function(MissingLowerCase<T> value) missingLowerCase,
    required TResult Function(MissingNumber<T> value) missingNumber,
    required TResult Function(IncludeNumber<T> value) includeNumber,
  }) {
    return multiline(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(InsufficientLength<T> value)? insufficientLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(DifferentInput<T> value)? differentInput,
    TResult Function(FailedInput<T> value)? failedInput,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(NumberTooLarge<T> value)? numberTooLarge,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortString<T> value)? shortString,
    TResult Function(InvalidPhotoUrl<T> value)? invalidPhotoUrl,
    TResult Function(ValidateMinStringLength<T> value)? validateMinStringLength,
    TResult Function(MissingUpperCase<T> value)? missingUpperCase,
    TResult Function(MissingLowerCase<T> value)? missingLowerCase,
    TResult Function(MissingNumber<T> value)? missingNumber,
    TResult Function(IncludeNumber<T> value)? includeNumber,
    required TResult orElse(),
  }) {
    if (multiline != null) {
      return multiline(this);
    }
    return orElse();
  }
}

abstract class Multiline<T> implements ValueFailure<T> {
  const factory Multiline({required T failedMessage}) = _$Multiline<T>;

  @override
  T get failedMessage => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  $MultilineCopyWith<T, Multiline<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NumberTooLargeCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $NumberTooLargeCopyWith(
          NumberTooLarge<T> value, $Res Function(NumberTooLarge<T>) then) =
      _$NumberTooLargeCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedMessage, num lenght});
}

/// @nodoc
class _$NumberTooLargeCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $NumberTooLargeCopyWith<T, $Res> {
  _$NumberTooLargeCopyWithImpl(
      NumberTooLarge<T> _value, $Res Function(NumberTooLarge<T>) _then)
      : super(_value, (v) => _then(v as NumberTooLarge<T>));

  @override
  NumberTooLarge<T> get _value => super._value as NumberTooLarge<T>;

  @override
  $Res call({
    Object? failedMessage = freezed,
    Object? lenght = freezed,
  }) {
    return _then(NumberTooLarge<T>(
      failedMessage: failedMessage == freezed
          ? _value.failedMessage
          : failedMessage // ignore: cast_nullable_to_non_nullable
              as T,
      lenght: lenght == freezed
          ? _value.lenght
          : lenght // ignore: cast_nullable_to_non_nullable
              as num,
    ));
  }
}

/// @nodoc

class _$NumberTooLarge<T> implements NumberTooLarge<T> {
  const _$NumberTooLarge({required this.failedMessage, required this.lenght});

  @override
  final T failedMessage;
  @override
  final num lenght;

  @override
  String toString() {
    return 'ValueFailure<$T>.numberTooLarge(failedMessage: $failedMessage, lenght: $lenght)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is NumberTooLarge<T> &&
            (identical(other.failedMessage, failedMessage) ||
                const DeepCollectionEquality()
                    .equals(other.failedMessage, failedMessage)) &&
            (identical(other.lenght, lenght) ||
                const DeepCollectionEquality().equals(other.lenght, lenght)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(failedMessage) ^
      const DeepCollectionEquality().hash(lenght);

  @JsonKey(ignore: true)
  @override
  $NumberTooLargeCopyWith<T, NumberTooLarge<T>> get copyWith =>
      _$NumberTooLargeCopyWithImpl<T, NumberTooLarge<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedMessage, int lenght) exceedingLength,
    required TResult Function(T failedMessage, int lenght) insufficientLength,
    required TResult Function(T failedMessage) empty,
    required TResult Function(T failedMessage) differentInput,
    required TResult Function(T failedMessage) failedInput,
    required TResult Function(T failedMessage) multiline,
    required TResult Function(T failedMessage, num lenght) numberTooLarge,
    required TResult Function(T failedMessage, int lenght) listTooLong,
    required TResult Function(T failedMessage) invalidEmail,
    required TResult Function(T failedMessage) shortString,
    required TResult Function(T failedMessage) invalidPhotoUrl,
    required TResult Function(T failedMessage) validateMinStringLength,
    required TResult Function(T failedMessage) missingUpperCase,
    required TResult Function(T failedMessage) missingLowerCase,
    required TResult Function(T failedMessage) missingNumber,
    required TResult Function(T failedMessage) includeNumber,
  }) {
    return numberTooLarge(failedMessage, lenght);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedMessage, int lenght)? exceedingLength,
    TResult Function(T failedMessage, int lenght)? insufficientLength,
    TResult Function(T failedMessage)? empty,
    TResult Function(T failedMessage)? differentInput,
    TResult Function(T failedMessage)? failedInput,
    TResult Function(T failedMessage)? multiline,
    TResult Function(T failedMessage, num lenght)? numberTooLarge,
    TResult Function(T failedMessage, int lenght)? listTooLong,
    TResult Function(T failedMessage)? invalidEmail,
    TResult Function(T failedMessage)? shortString,
    TResult Function(T failedMessage)? invalidPhotoUrl,
    TResult Function(T failedMessage)? validateMinStringLength,
    TResult Function(T failedMessage)? missingUpperCase,
    TResult Function(T failedMessage)? missingLowerCase,
    TResult Function(T failedMessage)? missingNumber,
    TResult Function(T failedMessage)? includeNumber,
    required TResult orElse(),
  }) {
    if (numberTooLarge != null) {
      return numberTooLarge(failedMessage, lenght);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(InsufficientLength<T> value) insufficientLength,
    required TResult Function(Empty<T> value) empty,
    required TResult Function(DifferentInput<T> value) differentInput,
    required TResult Function(FailedInput<T> value) failedInput,
    required TResult Function(Multiline<T> value) multiline,
    required TResult Function(NumberTooLarge<T> value) numberTooLarge,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortString<T> value) shortString,
    required TResult Function(InvalidPhotoUrl<T> value) invalidPhotoUrl,
    required TResult Function(ValidateMinStringLength<T> value)
        validateMinStringLength,
    required TResult Function(MissingUpperCase<T> value) missingUpperCase,
    required TResult Function(MissingLowerCase<T> value) missingLowerCase,
    required TResult Function(MissingNumber<T> value) missingNumber,
    required TResult Function(IncludeNumber<T> value) includeNumber,
  }) {
    return numberTooLarge(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(InsufficientLength<T> value)? insufficientLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(DifferentInput<T> value)? differentInput,
    TResult Function(FailedInput<T> value)? failedInput,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(NumberTooLarge<T> value)? numberTooLarge,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortString<T> value)? shortString,
    TResult Function(InvalidPhotoUrl<T> value)? invalidPhotoUrl,
    TResult Function(ValidateMinStringLength<T> value)? validateMinStringLength,
    TResult Function(MissingUpperCase<T> value)? missingUpperCase,
    TResult Function(MissingLowerCase<T> value)? missingLowerCase,
    TResult Function(MissingNumber<T> value)? missingNumber,
    TResult Function(IncludeNumber<T> value)? includeNumber,
    required TResult orElse(),
  }) {
    if (numberTooLarge != null) {
      return numberTooLarge(this);
    }
    return orElse();
  }
}

abstract class NumberTooLarge<T> implements ValueFailure<T> {
  const factory NumberTooLarge(
      {required T failedMessage, required num lenght}) = _$NumberTooLarge<T>;

  @override
  T get failedMessage => throw _privateConstructorUsedError;
  num get lenght => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  $NumberTooLargeCopyWith<T, NumberTooLarge<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ListTooLongCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $ListTooLongCopyWith(
          ListTooLong<T> value, $Res Function(ListTooLong<T>) then) =
      _$ListTooLongCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedMessage, int lenght});
}

/// @nodoc
class _$ListTooLongCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $ListTooLongCopyWith<T, $Res> {
  _$ListTooLongCopyWithImpl(
      ListTooLong<T> _value, $Res Function(ListTooLong<T>) _then)
      : super(_value, (v) => _then(v as ListTooLong<T>));

  @override
  ListTooLong<T> get _value => super._value as ListTooLong<T>;

  @override
  $Res call({
    Object? failedMessage = freezed,
    Object? lenght = freezed,
  }) {
    return _then(ListTooLong<T>(
      failedMessage: failedMessage == freezed
          ? _value.failedMessage
          : failedMessage // ignore: cast_nullable_to_non_nullable
              as T,
      lenght: lenght == freezed
          ? _value.lenght
          : lenght // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$ListTooLong<T> implements ListTooLong<T> {
  const _$ListTooLong({required this.failedMessage, required this.lenght});

  @override
  final T failedMessage;
  @override
  final int lenght;

  @override
  String toString() {
    return 'ValueFailure<$T>.listTooLong(failedMessage: $failedMessage, lenght: $lenght)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ListTooLong<T> &&
            (identical(other.failedMessage, failedMessage) ||
                const DeepCollectionEquality()
                    .equals(other.failedMessage, failedMessage)) &&
            (identical(other.lenght, lenght) ||
                const DeepCollectionEquality().equals(other.lenght, lenght)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(failedMessage) ^
      const DeepCollectionEquality().hash(lenght);

  @JsonKey(ignore: true)
  @override
  $ListTooLongCopyWith<T, ListTooLong<T>> get copyWith =>
      _$ListTooLongCopyWithImpl<T, ListTooLong<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedMessage, int lenght) exceedingLength,
    required TResult Function(T failedMessage, int lenght) insufficientLength,
    required TResult Function(T failedMessage) empty,
    required TResult Function(T failedMessage) differentInput,
    required TResult Function(T failedMessage) failedInput,
    required TResult Function(T failedMessage) multiline,
    required TResult Function(T failedMessage, num lenght) numberTooLarge,
    required TResult Function(T failedMessage, int lenght) listTooLong,
    required TResult Function(T failedMessage) invalidEmail,
    required TResult Function(T failedMessage) shortString,
    required TResult Function(T failedMessage) invalidPhotoUrl,
    required TResult Function(T failedMessage) validateMinStringLength,
    required TResult Function(T failedMessage) missingUpperCase,
    required TResult Function(T failedMessage) missingLowerCase,
    required TResult Function(T failedMessage) missingNumber,
    required TResult Function(T failedMessage) includeNumber,
  }) {
    return listTooLong(failedMessage, lenght);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedMessage, int lenght)? exceedingLength,
    TResult Function(T failedMessage, int lenght)? insufficientLength,
    TResult Function(T failedMessage)? empty,
    TResult Function(T failedMessage)? differentInput,
    TResult Function(T failedMessage)? failedInput,
    TResult Function(T failedMessage)? multiline,
    TResult Function(T failedMessage, num lenght)? numberTooLarge,
    TResult Function(T failedMessage, int lenght)? listTooLong,
    TResult Function(T failedMessage)? invalidEmail,
    TResult Function(T failedMessage)? shortString,
    TResult Function(T failedMessage)? invalidPhotoUrl,
    TResult Function(T failedMessage)? validateMinStringLength,
    TResult Function(T failedMessage)? missingUpperCase,
    TResult Function(T failedMessage)? missingLowerCase,
    TResult Function(T failedMessage)? missingNumber,
    TResult Function(T failedMessage)? includeNumber,
    required TResult orElse(),
  }) {
    if (listTooLong != null) {
      return listTooLong(failedMessage, lenght);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(InsufficientLength<T> value) insufficientLength,
    required TResult Function(Empty<T> value) empty,
    required TResult Function(DifferentInput<T> value) differentInput,
    required TResult Function(FailedInput<T> value) failedInput,
    required TResult Function(Multiline<T> value) multiline,
    required TResult Function(NumberTooLarge<T> value) numberTooLarge,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortString<T> value) shortString,
    required TResult Function(InvalidPhotoUrl<T> value) invalidPhotoUrl,
    required TResult Function(ValidateMinStringLength<T> value)
        validateMinStringLength,
    required TResult Function(MissingUpperCase<T> value) missingUpperCase,
    required TResult Function(MissingLowerCase<T> value) missingLowerCase,
    required TResult Function(MissingNumber<T> value) missingNumber,
    required TResult Function(IncludeNumber<T> value) includeNumber,
  }) {
    return listTooLong(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(InsufficientLength<T> value)? insufficientLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(DifferentInput<T> value)? differentInput,
    TResult Function(FailedInput<T> value)? failedInput,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(NumberTooLarge<T> value)? numberTooLarge,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortString<T> value)? shortString,
    TResult Function(InvalidPhotoUrl<T> value)? invalidPhotoUrl,
    TResult Function(ValidateMinStringLength<T> value)? validateMinStringLength,
    TResult Function(MissingUpperCase<T> value)? missingUpperCase,
    TResult Function(MissingLowerCase<T> value)? missingLowerCase,
    TResult Function(MissingNumber<T> value)? missingNumber,
    TResult Function(IncludeNumber<T> value)? includeNumber,
    required TResult orElse(),
  }) {
    if (listTooLong != null) {
      return listTooLong(this);
    }
    return orElse();
  }
}

abstract class ListTooLong<T> implements ValueFailure<T> {
  const factory ListTooLong({required T failedMessage, required int lenght}) =
      _$ListTooLong<T>;

  @override
  T get failedMessage => throw _privateConstructorUsedError;
  int get lenght => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  $ListTooLongCopyWith<T, ListTooLong<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InvalidEmailCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $InvalidEmailCopyWith(
          InvalidEmail<T> value, $Res Function(InvalidEmail<T>) then) =
      _$InvalidEmailCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedMessage});
}

/// @nodoc
class _$InvalidEmailCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidEmailCopyWith<T, $Res> {
  _$InvalidEmailCopyWithImpl(
      InvalidEmail<T> _value, $Res Function(InvalidEmail<T>) _then)
      : super(_value, (v) => _then(v as InvalidEmail<T>));

  @override
  InvalidEmail<T> get _value => super._value as InvalidEmail<T>;

  @override
  $Res call({
    Object? failedMessage = freezed,
  }) {
    return _then(InvalidEmail<T>(
      failedMessage: failedMessage == freezed
          ? _value.failedMessage
          : failedMessage // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$InvalidEmail<T> implements InvalidEmail<T> {
  const _$InvalidEmail({required this.failedMessage});

  @override
  final T failedMessage;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidEmail(failedMessage: $failedMessage)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidEmail<T> &&
            (identical(other.failedMessage, failedMessage) ||
                const DeepCollectionEquality()
                    .equals(other.failedMessage, failedMessage)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedMessage);

  @JsonKey(ignore: true)
  @override
  $InvalidEmailCopyWith<T, InvalidEmail<T>> get copyWith =>
      _$InvalidEmailCopyWithImpl<T, InvalidEmail<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedMessage, int lenght) exceedingLength,
    required TResult Function(T failedMessage, int lenght) insufficientLength,
    required TResult Function(T failedMessage) empty,
    required TResult Function(T failedMessage) differentInput,
    required TResult Function(T failedMessage) failedInput,
    required TResult Function(T failedMessage) multiline,
    required TResult Function(T failedMessage, num lenght) numberTooLarge,
    required TResult Function(T failedMessage, int lenght) listTooLong,
    required TResult Function(T failedMessage) invalidEmail,
    required TResult Function(T failedMessage) shortString,
    required TResult Function(T failedMessage) invalidPhotoUrl,
    required TResult Function(T failedMessage) validateMinStringLength,
    required TResult Function(T failedMessage) missingUpperCase,
    required TResult Function(T failedMessage) missingLowerCase,
    required TResult Function(T failedMessage) missingNumber,
    required TResult Function(T failedMessage) includeNumber,
  }) {
    return invalidEmail(failedMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedMessage, int lenght)? exceedingLength,
    TResult Function(T failedMessage, int lenght)? insufficientLength,
    TResult Function(T failedMessage)? empty,
    TResult Function(T failedMessage)? differentInput,
    TResult Function(T failedMessage)? failedInput,
    TResult Function(T failedMessage)? multiline,
    TResult Function(T failedMessage, num lenght)? numberTooLarge,
    TResult Function(T failedMessage, int lenght)? listTooLong,
    TResult Function(T failedMessage)? invalidEmail,
    TResult Function(T failedMessage)? shortString,
    TResult Function(T failedMessage)? invalidPhotoUrl,
    TResult Function(T failedMessage)? validateMinStringLength,
    TResult Function(T failedMessage)? missingUpperCase,
    TResult Function(T failedMessage)? missingLowerCase,
    TResult Function(T failedMessage)? missingNumber,
    TResult Function(T failedMessage)? includeNumber,
    required TResult orElse(),
  }) {
    if (invalidEmail != null) {
      return invalidEmail(failedMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(InsufficientLength<T> value) insufficientLength,
    required TResult Function(Empty<T> value) empty,
    required TResult Function(DifferentInput<T> value) differentInput,
    required TResult Function(FailedInput<T> value) failedInput,
    required TResult Function(Multiline<T> value) multiline,
    required TResult Function(NumberTooLarge<T> value) numberTooLarge,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortString<T> value) shortString,
    required TResult Function(InvalidPhotoUrl<T> value) invalidPhotoUrl,
    required TResult Function(ValidateMinStringLength<T> value)
        validateMinStringLength,
    required TResult Function(MissingUpperCase<T> value) missingUpperCase,
    required TResult Function(MissingLowerCase<T> value) missingLowerCase,
    required TResult Function(MissingNumber<T> value) missingNumber,
    required TResult Function(IncludeNumber<T> value) includeNumber,
  }) {
    return invalidEmail(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(InsufficientLength<T> value)? insufficientLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(DifferentInput<T> value)? differentInput,
    TResult Function(FailedInput<T> value)? failedInput,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(NumberTooLarge<T> value)? numberTooLarge,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortString<T> value)? shortString,
    TResult Function(InvalidPhotoUrl<T> value)? invalidPhotoUrl,
    TResult Function(ValidateMinStringLength<T> value)? validateMinStringLength,
    TResult Function(MissingUpperCase<T> value)? missingUpperCase,
    TResult Function(MissingLowerCase<T> value)? missingLowerCase,
    TResult Function(MissingNumber<T> value)? missingNumber,
    TResult Function(IncludeNumber<T> value)? includeNumber,
    required TResult orElse(),
  }) {
    if (invalidEmail != null) {
      return invalidEmail(this);
    }
    return orElse();
  }
}

abstract class InvalidEmail<T> implements ValueFailure<T> {
  const factory InvalidEmail({required T failedMessage}) = _$InvalidEmail<T>;

  @override
  T get failedMessage => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  $InvalidEmailCopyWith<T, InvalidEmail<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ShortStringCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $ShortStringCopyWith(
          ShortString<T> value, $Res Function(ShortString<T>) then) =
      _$ShortStringCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedMessage});
}

/// @nodoc
class _$ShortStringCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $ShortStringCopyWith<T, $Res> {
  _$ShortStringCopyWithImpl(
      ShortString<T> _value, $Res Function(ShortString<T>) _then)
      : super(_value, (v) => _then(v as ShortString<T>));

  @override
  ShortString<T> get _value => super._value as ShortString<T>;

  @override
  $Res call({
    Object? failedMessage = freezed,
  }) {
    return _then(ShortString<T>(
      failedMessage: failedMessage == freezed
          ? _value.failedMessage
          : failedMessage // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$ShortString<T> implements ShortString<T> {
  const _$ShortString({required this.failedMessage});

  @override
  final T failedMessage;

  @override
  String toString() {
    return 'ValueFailure<$T>.shortString(failedMessage: $failedMessage)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ShortString<T> &&
            (identical(other.failedMessage, failedMessage) ||
                const DeepCollectionEquality()
                    .equals(other.failedMessage, failedMessage)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedMessage);

  @JsonKey(ignore: true)
  @override
  $ShortStringCopyWith<T, ShortString<T>> get copyWith =>
      _$ShortStringCopyWithImpl<T, ShortString<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedMessage, int lenght) exceedingLength,
    required TResult Function(T failedMessage, int lenght) insufficientLength,
    required TResult Function(T failedMessage) empty,
    required TResult Function(T failedMessage) differentInput,
    required TResult Function(T failedMessage) failedInput,
    required TResult Function(T failedMessage) multiline,
    required TResult Function(T failedMessage, num lenght) numberTooLarge,
    required TResult Function(T failedMessage, int lenght) listTooLong,
    required TResult Function(T failedMessage) invalidEmail,
    required TResult Function(T failedMessage) shortString,
    required TResult Function(T failedMessage) invalidPhotoUrl,
    required TResult Function(T failedMessage) validateMinStringLength,
    required TResult Function(T failedMessage) missingUpperCase,
    required TResult Function(T failedMessage) missingLowerCase,
    required TResult Function(T failedMessage) missingNumber,
    required TResult Function(T failedMessage) includeNumber,
  }) {
    return shortString(failedMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedMessage, int lenght)? exceedingLength,
    TResult Function(T failedMessage, int lenght)? insufficientLength,
    TResult Function(T failedMessage)? empty,
    TResult Function(T failedMessage)? differentInput,
    TResult Function(T failedMessage)? failedInput,
    TResult Function(T failedMessage)? multiline,
    TResult Function(T failedMessage, num lenght)? numberTooLarge,
    TResult Function(T failedMessage, int lenght)? listTooLong,
    TResult Function(T failedMessage)? invalidEmail,
    TResult Function(T failedMessage)? shortString,
    TResult Function(T failedMessage)? invalidPhotoUrl,
    TResult Function(T failedMessage)? validateMinStringLength,
    TResult Function(T failedMessage)? missingUpperCase,
    TResult Function(T failedMessage)? missingLowerCase,
    TResult Function(T failedMessage)? missingNumber,
    TResult Function(T failedMessage)? includeNumber,
    required TResult orElse(),
  }) {
    if (shortString != null) {
      return shortString(failedMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(InsufficientLength<T> value) insufficientLength,
    required TResult Function(Empty<T> value) empty,
    required TResult Function(DifferentInput<T> value) differentInput,
    required TResult Function(FailedInput<T> value) failedInput,
    required TResult Function(Multiline<T> value) multiline,
    required TResult Function(NumberTooLarge<T> value) numberTooLarge,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortString<T> value) shortString,
    required TResult Function(InvalidPhotoUrl<T> value) invalidPhotoUrl,
    required TResult Function(ValidateMinStringLength<T> value)
        validateMinStringLength,
    required TResult Function(MissingUpperCase<T> value) missingUpperCase,
    required TResult Function(MissingLowerCase<T> value) missingLowerCase,
    required TResult Function(MissingNumber<T> value) missingNumber,
    required TResult Function(IncludeNumber<T> value) includeNumber,
  }) {
    return shortString(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(InsufficientLength<T> value)? insufficientLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(DifferentInput<T> value)? differentInput,
    TResult Function(FailedInput<T> value)? failedInput,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(NumberTooLarge<T> value)? numberTooLarge,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortString<T> value)? shortString,
    TResult Function(InvalidPhotoUrl<T> value)? invalidPhotoUrl,
    TResult Function(ValidateMinStringLength<T> value)? validateMinStringLength,
    TResult Function(MissingUpperCase<T> value)? missingUpperCase,
    TResult Function(MissingLowerCase<T> value)? missingLowerCase,
    TResult Function(MissingNumber<T> value)? missingNumber,
    TResult Function(IncludeNumber<T> value)? includeNumber,
    required TResult orElse(),
  }) {
    if (shortString != null) {
      return shortString(this);
    }
    return orElse();
  }
}

abstract class ShortString<T> implements ValueFailure<T> {
  const factory ShortString({required T failedMessage}) = _$ShortString<T>;

  @override
  T get failedMessage => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  $ShortStringCopyWith<T, ShortString<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InvalidPhotoUrlCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $InvalidPhotoUrlCopyWith(
          InvalidPhotoUrl<T> value, $Res Function(InvalidPhotoUrl<T>) then) =
      _$InvalidPhotoUrlCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedMessage});
}

/// @nodoc
class _$InvalidPhotoUrlCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidPhotoUrlCopyWith<T, $Res> {
  _$InvalidPhotoUrlCopyWithImpl(
      InvalidPhotoUrl<T> _value, $Res Function(InvalidPhotoUrl<T>) _then)
      : super(_value, (v) => _then(v as InvalidPhotoUrl<T>));

  @override
  InvalidPhotoUrl<T> get _value => super._value as InvalidPhotoUrl<T>;

  @override
  $Res call({
    Object? failedMessage = freezed,
  }) {
    return _then(InvalidPhotoUrl<T>(
      failedMessage: failedMessage == freezed
          ? _value.failedMessage
          : failedMessage // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$InvalidPhotoUrl<T> implements InvalidPhotoUrl<T> {
  const _$InvalidPhotoUrl({required this.failedMessage});

  @override
  final T failedMessage;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidPhotoUrl(failedMessage: $failedMessage)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidPhotoUrl<T> &&
            (identical(other.failedMessage, failedMessage) ||
                const DeepCollectionEquality()
                    .equals(other.failedMessage, failedMessage)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedMessage);

  @JsonKey(ignore: true)
  @override
  $InvalidPhotoUrlCopyWith<T, InvalidPhotoUrl<T>> get copyWith =>
      _$InvalidPhotoUrlCopyWithImpl<T, InvalidPhotoUrl<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedMessage, int lenght) exceedingLength,
    required TResult Function(T failedMessage, int lenght) insufficientLength,
    required TResult Function(T failedMessage) empty,
    required TResult Function(T failedMessage) differentInput,
    required TResult Function(T failedMessage) failedInput,
    required TResult Function(T failedMessage) multiline,
    required TResult Function(T failedMessage, num lenght) numberTooLarge,
    required TResult Function(T failedMessage, int lenght) listTooLong,
    required TResult Function(T failedMessage) invalidEmail,
    required TResult Function(T failedMessage) shortString,
    required TResult Function(T failedMessage) invalidPhotoUrl,
    required TResult Function(T failedMessage) validateMinStringLength,
    required TResult Function(T failedMessage) missingUpperCase,
    required TResult Function(T failedMessage) missingLowerCase,
    required TResult Function(T failedMessage) missingNumber,
    required TResult Function(T failedMessage) includeNumber,
  }) {
    return invalidPhotoUrl(failedMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedMessage, int lenght)? exceedingLength,
    TResult Function(T failedMessage, int lenght)? insufficientLength,
    TResult Function(T failedMessage)? empty,
    TResult Function(T failedMessage)? differentInput,
    TResult Function(T failedMessage)? failedInput,
    TResult Function(T failedMessage)? multiline,
    TResult Function(T failedMessage, num lenght)? numberTooLarge,
    TResult Function(T failedMessage, int lenght)? listTooLong,
    TResult Function(T failedMessage)? invalidEmail,
    TResult Function(T failedMessage)? shortString,
    TResult Function(T failedMessage)? invalidPhotoUrl,
    TResult Function(T failedMessage)? validateMinStringLength,
    TResult Function(T failedMessage)? missingUpperCase,
    TResult Function(T failedMessage)? missingLowerCase,
    TResult Function(T failedMessage)? missingNumber,
    TResult Function(T failedMessage)? includeNumber,
    required TResult orElse(),
  }) {
    if (invalidPhotoUrl != null) {
      return invalidPhotoUrl(failedMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(InsufficientLength<T> value) insufficientLength,
    required TResult Function(Empty<T> value) empty,
    required TResult Function(DifferentInput<T> value) differentInput,
    required TResult Function(FailedInput<T> value) failedInput,
    required TResult Function(Multiline<T> value) multiline,
    required TResult Function(NumberTooLarge<T> value) numberTooLarge,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortString<T> value) shortString,
    required TResult Function(InvalidPhotoUrl<T> value) invalidPhotoUrl,
    required TResult Function(ValidateMinStringLength<T> value)
        validateMinStringLength,
    required TResult Function(MissingUpperCase<T> value) missingUpperCase,
    required TResult Function(MissingLowerCase<T> value) missingLowerCase,
    required TResult Function(MissingNumber<T> value) missingNumber,
    required TResult Function(IncludeNumber<T> value) includeNumber,
  }) {
    return invalidPhotoUrl(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(InsufficientLength<T> value)? insufficientLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(DifferentInput<T> value)? differentInput,
    TResult Function(FailedInput<T> value)? failedInput,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(NumberTooLarge<T> value)? numberTooLarge,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortString<T> value)? shortString,
    TResult Function(InvalidPhotoUrl<T> value)? invalidPhotoUrl,
    TResult Function(ValidateMinStringLength<T> value)? validateMinStringLength,
    TResult Function(MissingUpperCase<T> value)? missingUpperCase,
    TResult Function(MissingLowerCase<T> value)? missingLowerCase,
    TResult Function(MissingNumber<T> value)? missingNumber,
    TResult Function(IncludeNumber<T> value)? includeNumber,
    required TResult orElse(),
  }) {
    if (invalidPhotoUrl != null) {
      return invalidPhotoUrl(this);
    }
    return orElse();
  }
}

abstract class InvalidPhotoUrl<T> implements ValueFailure<T> {
  const factory InvalidPhotoUrl({required T failedMessage}) =
      _$InvalidPhotoUrl<T>;

  @override
  T get failedMessage => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  $InvalidPhotoUrlCopyWith<T, InvalidPhotoUrl<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ValidateMinStringLengthCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $ValidateMinStringLengthCopyWith(ValidateMinStringLength<T> value,
          $Res Function(ValidateMinStringLength<T>) then) =
      _$ValidateMinStringLengthCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedMessage});
}

/// @nodoc
class _$ValidateMinStringLengthCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $ValidateMinStringLengthCopyWith<T, $Res> {
  _$ValidateMinStringLengthCopyWithImpl(ValidateMinStringLength<T> _value,
      $Res Function(ValidateMinStringLength<T>) _then)
      : super(_value, (v) => _then(v as ValidateMinStringLength<T>));

  @override
  ValidateMinStringLength<T> get _value =>
      super._value as ValidateMinStringLength<T>;

  @override
  $Res call({
    Object? failedMessage = freezed,
  }) {
    return _then(ValidateMinStringLength<T>(
      failedMessage: failedMessage == freezed
          ? _value.failedMessage
          : failedMessage // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$ValidateMinStringLength<T> implements ValidateMinStringLength<T> {
  const _$ValidateMinStringLength({required this.failedMessage});

  @override
  final T failedMessage;

  @override
  String toString() {
    return 'ValueFailure<$T>.validateMinStringLength(failedMessage: $failedMessage)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ValidateMinStringLength<T> &&
            (identical(other.failedMessage, failedMessage) ||
                const DeepCollectionEquality()
                    .equals(other.failedMessage, failedMessage)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedMessage);

  @JsonKey(ignore: true)
  @override
  $ValidateMinStringLengthCopyWith<T, ValidateMinStringLength<T>>
      get copyWith =>
          _$ValidateMinStringLengthCopyWithImpl<T, ValidateMinStringLength<T>>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedMessage, int lenght) exceedingLength,
    required TResult Function(T failedMessage, int lenght) insufficientLength,
    required TResult Function(T failedMessage) empty,
    required TResult Function(T failedMessage) differentInput,
    required TResult Function(T failedMessage) failedInput,
    required TResult Function(T failedMessage) multiline,
    required TResult Function(T failedMessage, num lenght) numberTooLarge,
    required TResult Function(T failedMessage, int lenght) listTooLong,
    required TResult Function(T failedMessage) invalidEmail,
    required TResult Function(T failedMessage) shortString,
    required TResult Function(T failedMessage) invalidPhotoUrl,
    required TResult Function(T failedMessage) validateMinStringLength,
    required TResult Function(T failedMessage) missingUpperCase,
    required TResult Function(T failedMessage) missingLowerCase,
    required TResult Function(T failedMessage) missingNumber,
    required TResult Function(T failedMessage) includeNumber,
  }) {
    return validateMinStringLength(failedMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedMessage, int lenght)? exceedingLength,
    TResult Function(T failedMessage, int lenght)? insufficientLength,
    TResult Function(T failedMessage)? empty,
    TResult Function(T failedMessage)? differentInput,
    TResult Function(T failedMessage)? failedInput,
    TResult Function(T failedMessage)? multiline,
    TResult Function(T failedMessage, num lenght)? numberTooLarge,
    TResult Function(T failedMessage, int lenght)? listTooLong,
    TResult Function(T failedMessage)? invalidEmail,
    TResult Function(T failedMessage)? shortString,
    TResult Function(T failedMessage)? invalidPhotoUrl,
    TResult Function(T failedMessage)? validateMinStringLength,
    TResult Function(T failedMessage)? missingUpperCase,
    TResult Function(T failedMessage)? missingLowerCase,
    TResult Function(T failedMessage)? missingNumber,
    TResult Function(T failedMessage)? includeNumber,
    required TResult orElse(),
  }) {
    if (validateMinStringLength != null) {
      return validateMinStringLength(failedMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(InsufficientLength<T> value) insufficientLength,
    required TResult Function(Empty<T> value) empty,
    required TResult Function(DifferentInput<T> value) differentInput,
    required TResult Function(FailedInput<T> value) failedInput,
    required TResult Function(Multiline<T> value) multiline,
    required TResult Function(NumberTooLarge<T> value) numberTooLarge,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortString<T> value) shortString,
    required TResult Function(InvalidPhotoUrl<T> value) invalidPhotoUrl,
    required TResult Function(ValidateMinStringLength<T> value)
        validateMinStringLength,
    required TResult Function(MissingUpperCase<T> value) missingUpperCase,
    required TResult Function(MissingLowerCase<T> value) missingLowerCase,
    required TResult Function(MissingNumber<T> value) missingNumber,
    required TResult Function(IncludeNumber<T> value) includeNumber,
  }) {
    return validateMinStringLength(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(InsufficientLength<T> value)? insufficientLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(DifferentInput<T> value)? differentInput,
    TResult Function(FailedInput<T> value)? failedInput,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(NumberTooLarge<T> value)? numberTooLarge,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortString<T> value)? shortString,
    TResult Function(InvalidPhotoUrl<T> value)? invalidPhotoUrl,
    TResult Function(ValidateMinStringLength<T> value)? validateMinStringLength,
    TResult Function(MissingUpperCase<T> value)? missingUpperCase,
    TResult Function(MissingLowerCase<T> value)? missingLowerCase,
    TResult Function(MissingNumber<T> value)? missingNumber,
    TResult Function(IncludeNumber<T> value)? includeNumber,
    required TResult orElse(),
  }) {
    if (validateMinStringLength != null) {
      return validateMinStringLength(this);
    }
    return orElse();
  }
}

abstract class ValidateMinStringLength<T> implements ValueFailure<T> {
  const factory ValidateMinStringLength({required T failedMessage}) =
      _$ValidateMinStringLength<T>;

  @override
  T get failedMessage => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  $ValidateMinStringLengthCopyWith<T, ValidateMinStringLength<T>>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MissingUpperCaseCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $MissingUpperCaseCopyWith(
          MissingUpperCase<T> value, $Res Function(MissingUpperCase<T>) then) =
      _$MissingUpperCaseCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedMessage});
}

/// @nodoc
class _$MissingUpperCaseCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $MissingUpperCaseCopyWith<T, $Res> {
  _$MissingUpperCaseCopyWithImpl(
      MissingUpperCase<T> _value, $Res Function(MissingUpperCase<T>) _then)
      : super(_value, (v) => _then(v as MissingUpperCase<T>));

  @override
  MissingUpperCase<T> get _value => super._value as MissingUpperCase<T>;

  @override
  $Res call({
    Object? failedMessage = freezed,
  }) {
    return _then(MissingUpperCase<T>(
      failedMessage: failedMessage == freezed
          ? _value.failedMessage
          : failedMessage // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$MissingUpperCase<T> implements MissingUpperCase<T> {
  const _$MissingUpperCase({required this.failedMessage});

  @override
  final T failedMessage;

  @override
  String toString() {
    return 'ValueFailure<$T>.missingUpperCase(failedMessage: $failedMessage)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is MissingUpperCase<T> &&
            (identical(other.failedMessage, failedMessage) ||
                const DeepCollectionEquality()
                    .equals(other.failedMessage, failedMessage)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedMessage);

  @JsonKey(ignore: true)
  @override
  $MissingUpperCaseCopyWith<T, MissingUpperCase<T>> get copyWith =>
      _$MissingUpperCaseCopyWithImpl<T, MissingUpperCase<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedMessage, int lenght) exceedingLength,
    required TResult Function(T failedMessage, int lenght) insufficientLength,
    required TResult Function(T failedMessage) empty,
    required TResult Function(T failedMessage) differentInput,
    required TResult Function(T failedMessage) failedInput,
    required TResult Function(T failedMessage) multiline,
    required TResult Function(T failedMessage, num lenght) numberTooLarge,
    required TResult Function(T failedMessage, int lenght) listTooLong,
    required TResult Function(T failedMessage) invalidEmail,
    required TResult Function(T failedMessage) shortString,
    required TResult Function(T failedMessage) invalidPhotoUrl,
    required TResult Function(T failedMessage) validateMinStringLength,
    required TResult Function(T failedMessage) missingUpperCase,
    required TResult Function(T failedMessage) missingLowerCase,
    required TResult Function(T failedMessage) missingNumber,
    required TResult Function(T failedMessage) includeNumber,
  }) {
    return missingUpperCase(failedMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedMessage, int lenght)? exceedingLength,
    TResult Function(T failedMessage, int lenght)? insufficientLength,
    TResult Function(T failedMessage)? empty,
    TResult Function(T failedMessage)? differentInput,
    TResult Function(T failedMessage)? failedInput,
    TResult Function(T failedMessage)? multiline,
    TResult Function(T failedMessage, num lenght)? numberTooLarge,
    TResult Function(T failedMessage, int lenght)? listTooLong,
    TResult Function(T failedMessage)? invalidEmail,
    TResult Function(T failedMessage)? shortString,
    TResult Function(T failedMessage)? invalidPhotoUrl,
    TResult Function(T failedMessage)? validateMinStringLength,
    TResult Function(T failedMessage)? missingUpperCase,
    TResult Function(T failedMessage)? missingLowerCase,
    TResult Function(T failedMessage)? missingNumber,
    TResult Function(T failedMessage)? includeNumber,
    required TResult orElse(),
  }) {
    if (missingUpperCase != null) {
      return missingUpperCase(failedMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(InsufficientLength<T> value) insufficientLength,
    required TResult Function(Empty<T> value) empty,
    required TResult Function(DifferentInput<T> value) differentInput,
    required TResult Function(FailedInput<T> value) failedInput,
    required TResult Function(Multiline<T> value) multiline,
    required TResult Function(NumberTooLarge<T> value) numberTooLarge,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortString<T> value) shortString,
    required TResult Function(InvalidPhotoUrl<T> value) invalidPhotoUrl,
    required TResult Function(ValidateMinStringLength<T> value)
        validateMinStringLength,
    required TResult Function(MissingUpperCase<T> value) missingUpperCase,
    required TResult Function(MissingLowerCase<T> value) missingLowerCase,
    required TResult Function(MissingNumber<T> value) missingNumber,
    required TResult Function(IncludeNumber<T> value) includeNumber,
  }) {
    return missingUpperCase(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(InsufficientLength<T> value)? insufficientLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(DifferentInput<T> value)? differentInput,
    TResult Function(FailedInput<T> value)? failedInput,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(NumberTooLarge<T> value)? numberTooLarge,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortString<T> value)? shortString,
    TResult Function(InvalidPhotoUrl<T> value)? invalidPhotoUrl,
    TResult Function(ValidateMinStringLength<T> value)? validateMinStringLength,
    TResult Function(MissingUpperCase<T> value)? missingUpperCase,
    TResult Function(MissingLowerCase<T> value)? missingLowerCase,
    TResult Function(MissingNumber<T> value)? missingNumber,
    TResult Function(IncludeNumber<T> value)? includeNumber,
    required TResult orElse(),
  }) {
    if (missingUpperCase != null) {
      return missingUpperCase(this);
    }
    return orElse();
  }
}

abstract class MissingUpperCase<T> implements ValueFailure<T> {
  const factory MissingUpperCase({required T failedMessage}) =
      _$MissingUpperCase<T>;

  @override
  T get failedMessage => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  $MissingUpperCaseCopyWith<T, MissingUpperCase<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MissingLowerCaseCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $MissingLowerCaseCopyWith(
          MissingLowerCase<T> value, $Res Function(MissingLowerCase<T>) then) =
      _$MissingLowerCaseCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedMessage});
}

/// @nodoc
class _$MissingLowerCaseCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $MissingLowerCaseCopyWith<T, $Res> {
  _$MissingLowerCaseCopyWithImpl(
      MissingLowerCase<T> _value, $Res Function(MissingLowerCase<T>) _then)
      : super(_value, (v) => _then(v as MissingLowerCase<T>));

  @override
  MissingLowerCase<T> get _value => super._value as MissingLowerCase<T>;

  @override
  $Res call({
    Object? failedMessage = freezed,
  }) {
    return _then(MissingLowerCase<T>(
      failedMessage: failedMessage == freezed
          ? _value.failedMessage
          : failedMessage // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$MissingLowerCase<T> implements MissingLowerCase<T> {
  const _$MissingLowerCase({required this.failedMessage});

  @override
  final T failedMessage;

  @override
  String toString() {
    return 'ValueFailure<$T>.missingLowerCase(failedMessage: $failedMessage)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is MissingLowerCase<T> &&
            (identical(other.failedMessage, failedMessage) ||
                const DeepCollectionEquality()
                    .equals(other.failedMessage, failedMessage)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedMessage);

  @JsonKey(ignore: true)
  @override
  $MissingLowerCaseCopyWith<T, MissingLowerCase<T>> get copyWith =>
      _$MissingLowerCaseCopyWithImpl<T, MissingLowerCase<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedMessage, int lenght) exceedingLength,
    required TResult Function(T failedMessage, int lenght) insufficientLength,
    required TResult Function(T failedMessage) empty,
    required TResult Function(T failedMessage) differentInput,
    required TResult Function(T failedMessage) failedInput,
    required TResult Function(T failedMessage) multiline,
    required TResult Function(T failedMessage, num lenght) numberTooLarge,
    required TResult Function(T failedMessage, int lenght) listTooLong,
    required TResult Function(T failedMessage) invalidEmail,
    required TResult Function(T failedMessage) shortString,
    required TResult Function(T failedMessage) invalidPhotoUrl,
    required TResult Function(T failedMessage) validateMinStringLength,
    required TResult Function(T failedMessage) missingUpperCase,
    required TResult Function(T failedMessage) missingLowerCase,
    required TResult Function(T failedMessage) missingNumber,
    required TResult Function(T failedMessage) includeNumber,
  }) {
    return missingLowerCase(failedMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedMessage, int lenght)? exceedingLength,
    TResult Function(T failedMessage, int lenght)? insufficientLength,
    TResult Function(T failedMessage)? empty,
    TResult Function(T failedMessage)? differentInput,
    TResult Function(T failedMessage)? failedInput,
    TResult Function(T failedMessage)? multiline,
    TResult Function(T failedMessage, num lenght)? numberTooLarge,
    TResult Function(T failedMessage, int lenght)? listTooLong,
    TResult Function(T failedMessage)? invalidEmail,
    TResult Function(T failedMessage)? shortString,
    TResult Function(T failedMessage)? invalidPhotoUrl,
    TResult Function(T failedMessage)? validateMinStringLength,
    TResult Function(T failedMessage)? missingUpperCase,
    TResult Function(T failedMessage)? missingLowerCase,
    TResult Function(T failedMessage)? missingNumber,
    TResult Function(T failedMessage)? includeNumber,
    required TResult orElse(),
  }) {
    if (missingLowerCase != null) {
      return missingLowerCase(failedMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(InsufficientLength<T> value) insufficientLength,
    required TResult Function(Empty<T> value) empty,
    required TResult Function(DifferentInput<T> value) differentInput,
    required TResult Function(FailedInput<T> value) failedInput,
    required TResult Function(Multiline<T> value) multiline,
    required TResult Function(NumberTooLarge<T> value) numberTooLarge,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortString<T> value) shortString,
    required TResult Function(InvalidPhotoUrl<T> value) invalidPhotoUrl,
    required TResult Function(ValidateMinStringLength<T> value)
        validateMinStringLength,
    required TResult Function(MissingUpperCase<T> value) missingUpperCase,
    required TResult Function(MissingLowerCase<T> value) missingLowerCase,
    required TResult Function(MissingNumber<T> value) missingNumber,
    required TResult Function(IncludeNumber<T> value) includeNumber,
  }) {
    return missingLowerCase(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(InsufficientLength<T> value)? insufficientLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(DifferentInput<T> value)? differentInput,
    TResult Function(FailedInput<T> value)? failedInput,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(NumberTooLarge<T> value)? numberTooLarge,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortString<T> value)? shortString,
    TResult Function(InvalidPhotoUrl<T> value)? invalidPhotoUrl,
    TResult Function(ValidateMinStringLength<T> value)? validateMinStringLength,
    TResult Function(MissingUpperCase<T> value)? missingUpperCase,
    TResult Function(MissingLowerCase<T> value)? missingLowerCase,
    TResult Function(MissingNumber<T> value)? missingNumber,
    TResult Function(IncludeNumber<T> value)? includeNumber,
    required TResult orElse(),
  }) {
    if (missingLowerCase != null) {
      return missingLowerCase(this);
    }
    return orElse();
  }
}

abstract class MissingLowerCase<T> implements ValueFailure<T> {
  const factory MissingLowerCase({required T failedMessage}) =
      _$MissingLowerCase<T>;

  @override
  T get failedMessage => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  $MissingLowerCaseCopyWith<T, MissingLowerCase<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MissingNumberCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $MissingNumberCopyWith(
          MissingNumber<T> value, $Res Function(MissingNumber<T>) then) =
      _$MissingNumberCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedMessage});
}

/// @nodoc
class _$MissingNumberCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $MissingNumberCopyWith<T, $Res> {
  _$MissingNumberCopyWithImpl(
      MissingNumber<T> _value, $Res Function(MissingNumber<T>) _then)
      : super(_value, (v) => _then(v as MissingNumber<T>));

  @override
  MissingNumber<T> get _value => super._value as MissingNumber<T>;

  @override
  $Res call({
    Object? failedMessage = freezed,
  }) {
    return _then(MissingNumber<T>(
      failedMessage: failedMessage == freezed
          ? _value.failedMessage
          : failedMessage // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$MissingNumber<T> implements MissingNumber<T> {
  const _$MissingNumber({required this.failedMessage});

  @override
  final T failedMessage;

  @override
  String toString() {
    return 'ValueFailure<$T>.missingNumber(failedMessage: $failedMessage)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is MissingNumber<T> &&
            (identical(other.failedMessage, failedMessage) ||
                const DeepCollectionEquality()
                    .equals(other.failedMessage, failedMessage)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedMessage);

  @JsonKey(ignore: true)
  @override
  $MissingNumberCopyWith<T, MissingNumber<T>> get copyWith =>
      _$MissingNumberCopyWithImpl<T, MissingNumber<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedMessage, int lenght) exceedingLength,
    required TResult Function(T failedMessage, int lenght) insufficientLength,
    required TResult Function(T failedMessage) empty,
    required TResult Function(T failedMessage) differentInput,
    required TResult Function(T failedMessage) failedInput,
    required TResult Function(T failedMessage) multiline,
    required TResult Function(T failedMessage, num lenght) numberTooLarge,
    required TResult Function(T failedMessage, int lenght) listTooLong,
    required TResult Function(T failedMessage) invalidEmail,
    required TResult Function(T failedMessage) shortString,
    required TResult Function(T failedMessage) invalidPhotoUrl,
    required TResult Function(T failedMessage) validateMinStringLength,
    required TResult Function(T failedMessage) missingUpperCase,
    required TResult Function(T failedMessage) missingLowerCase,
    required TResult Function(T failedMessage) missingNumber,
    required TResult Function(T failedMessage) includeNumber,
  }) {
    return missingNumber(failedMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedMessage, int lenght)? exceedingLength,
    TResult Function(T failedMessage, int lenght)? insufficientLength,
    TResult Function(T failedMessage)? empty,
    TResult Function(T failedMessage)? differentInput,
    TResult Function(T failedMessage)? failedInput,
    TResult Function(T failedMessage)? multiline,
    TResult Function(T failedMessage, num lenght)? numberTooLarge,
    TResult Function(T failedMessage, int lenght)? listTooLong,
    TResult Function(T failedMessage)? invalidEmail,
    TResult Function(T failedMessage)? shortString,
    TResult Function(T failedMessage)? invalidPhotoUrl,
    TResult Function(T failedMessage)? validateMinStringLength,
    TResult Function(T failedMessage)? missingUpperCase,
    TResult Function(T failedMessage)? missingLowerCase,
    TResult Function(T failedMessage)? missingNumber,
    TResult Function(T failedMessage)? includeNumber,
    required TResult orElse(),
  }) {
    if (missingNumber != null) {
      return missingNumber(failedMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(InsufficientLength<T> value) insufficientLength,
    required TResult Function(Empty<T> value) empty,
    required TResult Function(DifferentInput<T> value) differentInput,
    required TResult Function(FailedInput<T> value) failedInput,
    required TResult Function(Multiline<T> value) multiline,
    required TResult Function(NumberTooLarge<T> value) numberTooLarge,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortString<T> value) shortString,
    required TResult Function(InvalidPhotoUrl<T> value) invalidPhotoUrl,
    required TResult Function(ValidateMinStringLength<T> value)
        validateMinStringLength,
    required TResult Function(MissingUpperCase<T> value) missingUpperCase,
    required TResult Function(MissingLowerCase<T> value) missingLowerCase,
    required TResult Function(MissingNumber<T> value) missingNumber,
    required TResult Function(IncludeNumber<T> value) includeNumber,
  }) {
    return missingNumber(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(InsufficientLength<T> value)? insufficientLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(DifferentInput<T> value)? differentInput,
    TResult Function(FailedInput<T> value)? failedInput,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(NumberTooLarge<T> value)? numberTooLarge,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortString<T> value)? shortString,
    TResult Function(InvalidPhotoUrl<T> value)? invalidPhotoUrl,
    TResult Function(ValidateMinStringLength<T> value)? validateMinStringLength,
    TResult Function(MissingUpperCase<T> value)? missingUpperCase,
    TResult Function(MissingLowerCase<T> value)? missingLowerCase,
    TResult Function(MissingNumber<T> value)? missingNumber,
    TResult Function(IncludeNumber<T> value)? includeNumber,
    required TResult orElse(),
  }) {
    if (missingNumber != null) {
      return missingNumber(this);
    }
    return orElse();
  }
}

abstract class MissingNumber<T> implements ValueFailure<T> {
  const factory MissingNumber({required T failedMessage}) = _$MissingNumber<T>;

  @override
  T get failedMessage => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  $MissingNumberCopyWith<T, MissingNumber<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $IncludeNumberCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $IncludeNumberCopyWith(
          IncludeNumber<T> value, $Res Function(IncludeNumber<T>) then) =
      _$IncludeNumberCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedMessage});
}

/// @nodoc
class _$IncludeNumberCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $IncludeNumberCopyWith<T, $Res> {
  _$IncludeNumberCopyWithImpl(
      IncludeNumber<T> _value, $Res Function(IncludeNumber<T>) _then)
      : super(_value, (v) => _then(v as IncludeNumber<T>));

  @override
  IncludeNumber<T> get _value => super._value as IncludeNumber<T>;

  @override
  $Res call({
    Object? failedMessage = freezed,
  }) {
    return _then(IncludeNumber<T>(
      failedMessage: failedMessage == freezed
          ? _value.failedMessage
          : failedMessage // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$IncludeNumber<T> implements IncludeNumber<T> {
  const _$IncludeNumber({required this.failedMessage});

  @override
  final T failedMessage;

  @override
  String toString() {
    return 'ValueFailure<$T>.includeNumber(failedMessage: $failedMessage)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IncludeNumber<T> &&
            (identical(other.failedMessage, failedMessage) ||
                const DeepCollectionEquality()
                    .equals(other.failedMessage, failedMessage)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedMessage);

  @JsonKey(ignore: true)
  @override
  $IncludeNumberCopyWith<T, IncludeNumber<T>> get copyWith =>
      _$IncludeNumberCopyWithImpl<T, IncludeNumber<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedMessage, int lenght) exceedingLength,
    required TResult Function(T failedMessage, int lenght) insufficientLength,
    required TResult Function(T failedMessage) empty,
    required TResult Function(T failedMessage) differentInput,
    required TResult Function(T failedMessage) failedInput,
    required TResult Function(T failedMessage) multiline,
    required TResult Function(T failedMessage, num lenght) numberTooLarge,
    required TResult Function(T failedMessage, int lenght) listTooLong,
    required TResult Function(T failedMessage) invalidEmail,
    required TResult Function(T failedMessage) shortString,
    required TResult Function(T failedMessage) invalidPhotoUrl,
    required TResult Function(T failedMessage) validateMinStringLength,
    required TResult Function(T failedMessage) missingUpperCase,
    required TResult Function(T failedMessage) missingLowerCase,
    required TResult Function(T failedMessage) missingNumber,
    required TResult Function(T failedMessage) includeNumber,
  }) {
    return includeNumber(failedMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedMessage, int lenght)? exceedingLength,
    TResult Function(T failedMessage, int lenght)? insufficientLength,
    TResult Function(T failedMessage)? empty,
    TResult Function(T failedMessage)? differentInput,
    TResult Function(T failedMessage)? failedInput,
    TResult Function(T failedMessage)? multiline,
    TResult Function(T failedMessage, num lenght)? numberTooLarge,
    TResult Function(T failedMessage, int lenght)? listTooLong,
    TResult Function(T failedMessage)? invalidEmail,
    TResult Function(T failedMessage)? shortString,
    TResult Function(T failedMessage)? invalidPhotoUrl,
    TResult Function(T failedMessage)? validateMinStringLength,
    TResult Function(T failedMessage)? missingUpperCase,
    TResult Function(T failedMessage)? missingLowerCase,
    TResult Function(T failedMessage)? missingNumber,
    TResult Function(T failedMessage)? includeNumber,
    required TResult orElse(),
  }) {
    if (includeNumber != null) {
      return includeNumber(failedMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(InsufficientLength<T> value) insufficientLength,
    required TResult Function(Empty<T> value) empty,
    required TResult Function(DifferentInput<T> value) differentInput,
    required TResult Function(FailedInput<T> value) failedInput,
    required TResult Function(Multiline<T> value) multiline,
    required TResult Function(NumberTooLarge<T> value) numberTooLarge,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortString<T> value) shortString,
    required TResult Function(InvalidPhotoUrl<T> value) invalidPhotoUrl,
    required TResult Function(ValidateMinStringLength<T> value)
        validateMinStringLength,
    required TResult Function(MissingUpperCase<T> value) missingUpperCase,
    required TResult Function(MissingLowerCase<T> value) missingLowerCase,
    required TResult Function(MissingNumber<T> value) missingNumber,
    required TResult Function(IncludeNumber<T> value) includeNumber,
  }) {
    return includeNumber(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(InsufficientLength<T> value)? insufficientLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(DifferentInput<T> value)? differentInput,
    TResult Function(FailedInput<T> value)? failedInput,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(NumberTooLarge<T> value)? numberTooLarge,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortString<T> value)? shortString,
    TResult Function(InvalidPhotoUrl<T> value)? invalidPhotoUrl,
    TResult Function(ValidateMinStringLength<T> value)? validateMinStringLength,
    TResult Function(MissingUpperCase<T> value)? missingUpperCase,
    TResult Function(MissingLowerCase<T> value)? missingLowerCase,
    TResult Function(MissingNumber<T> value)? missingNumber,
    TResult Function(IncludeNumber<T> value)? includeNumber,
    required TResult orElse(),
  }) {
    if (includeNumber != null) {
      return includeNumber(this);
    }
    return orElse();
  }
}

abstract class IncludeNumber<T> implements ValueFailure<T> {
  const factory IncludeNumber({required T failedMessage}) = _$IncludeNumber<T>;

  @override
  T get failedMessage => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  $IncludeNumberCopyWith<T, IncludeNumber<T>> get copyWith =>
      throw _privateConstructorUsedError;
}
